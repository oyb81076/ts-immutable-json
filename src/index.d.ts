import { Collection as Iterable, List, Map, OrderedMap, OrderedSet, Seq } from "immutable";
declare type Basic<T> = T extends (string | number | boolean | Date | null | undefined | Iterable<any, any>) ? T : IRecord<T>;
declare type Value<T> = T extends any[] ? List<Basic<T[number]>> : Basic<T>;
export interface IRecord<T> {
  readonly size: number;
  get<K extends keyof T>(key: K, notSetValue?: Value<T[K]>): Value<T[K]>;
  set<K extends keyof T>(key: K, value: Value<T[K]>): this;
  delete<K extends keyof T>(key: K): this;
  clear(): this;
  update(updater: (value: this) => this): this;
  update<K extends keyof T>(key: K, updater: (value: Value<T[K]>) => Value<T[K]>): this;
  update<K extends keyof T>(key: K, notSetValue: Value<T[K]>, updater: (value: Value<T[K]>) => Value<T[K]>): this;
  merge<K extends keyof T, V = Value<T[K]>>(...iterables: Array<Iterable<K, V>>): this;
  merge(...iterables: Array<Partial<T>>): this;
  mergeWith<K extends keyof T, V = Value<T[K]>>(merger: (previous?: V, next?: V, key?: K) => V, ...iterables: Array<Iterable<K, V>>): this;
  mergeWith<K extends keyof T, V = Value<T[K]>>(merger: (previous?: V, next?: T[K], key?: K) => V, ...iterables: T[]): this;
  mergeDeep<K extends keyof T, V = Value<T[K]>>(...iterables: Array<Iterable<K, V>>): this;
  mergeDeep(...iterables: T[]): this;
  mergeDeepWith<K extends keyof T, V = Value<T[K]>>(merger: (previous?: V, next?: V, key?: K) => V, ...iterables: Array<Iterable<K, V>>): this;
  mergeDeepWith<K extends keyof T, V = Value<T[K]>>(merger: (previous?: V, next?: T[K], key?: K) => V, ...iterables: T[]): this;
  setIn(keyPath: any[] | Iterable<any, any>, value: any): this;
  deleteIn(keyPath: any[] | Iterable<any, any>): this;
  removeIn(keyPath: any[] | Iterable<any, any>): this;
  mergeIn(keyPath: any[] | Iterable<any, any>, ...iterables: Array<Iterable<any, any> | any>): this;
  mergeDeepIn(keyPath: any[] | Iterable<any, any>, ...iterables: Array<Iterable<any, any> | any>): this;
  withMutations(mutator: (mutable: this) => any): this;
  asMutable(): this;
  asImmutable(): this;
  toJS(): T;
  equals(t: any): boolean;
  has<K extends keyof T>(key: K): boolean;
  includes(value: Value<T[keyof T]>): boolean;
  contains(value: Value<T[keyof T]>): boolean;
  first(): Value<T[keyof T]>;
  last(): Value<T[keyof T]>;
  getIn<K1 extends keyof T, V = Value<T[K1]>>(searchKeyPath: [K1], notSetValue?: V): V;
  getIn<K1 extends keyof T, K2 extends keyof T[K1], V = Value<T[K1][K2]>>(searchKeyPath: [K1, K2], notSetValue?: V): V;
  getIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], V = Value<T[K1][K2][K3]>>(searchKeyPath: [K1, K2, K3], notSetValue?: V): V;
  getIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], V = Value<T[K1][K2][K3][K4]>>(searchKeyPath: [K1, K2, K3, K4], notSetValue?: V): V;
  getIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], V = Value<T[K1][K2][K3][K4][K5]>>(searchKeyPath: [K1, K2, K3, K4, K5], notSetValue?: V): V;
  getIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5], V = Value<T[K1][K2][K3][K4][K5][K6]>>(searchKeyPath: [K1, K2, K3, K4, K5, K6], notSetValue?: V): V;
  getIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5], K7 extends keyof T[K1][K2][K3][K4][K5][K6], V = Value<T[K1][K2][K3][K4][K5][K6][K7]>>(searchKeyPath: [K1, K2, K3, K4, K5, K6, K7], notSetValue?: V): V;
  getIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5], K7 extends keyof T[K1][K2][K3][K4][K5][K6], K8 extends keyof T[K1][K2][K3][K4][K5][K6][K7], V = Value<T[K1][K2][K3][K4][K5][K6][K7][K8]>>(searchKeyPath: [K1, K2, K3, K4, K5, K6, K7, K8], notSetValue?: V): V;
  getIn<V>(searchKeyPath: Iterable<any, any>, notSetValue?: V): V;
  updateIn<K1 extends keyof T>(keyPath: [K1], updater: (value?: Value<T[K1]>) => Value<T[K1]>): this;
  updateIn<K1 extends keyof T>(keyPath: [K1], notSetValue: Value<T[K1]>, updater: (value: Value<T[K1]>) => Value<T[K1]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1]>(keyPath: [K1, K2], updater: (value?: Value<T[K1][K2]>) => Value<T[K1][K2]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1]>(keyPath: [K1, K2], notSetValue: Value<T[K1][K2]>, updater: (value?: Value<T[K1][K2]>) => Value<T[K1][K2]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(keyPath: [K1, K2, K3], updater: (value?: Value<T[K1][K2][K3]>) => Value<T[K1][K2][K3]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(keyPath: [K1, K2, K3], notSetValue: Value<T[K1][K2][K3]>, updater: (value?: Value<T[K1][K2][K3]>) => Value<T[K1][K2][K3]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(keyPath: [K1, K2, K3, K4], updater: (value?: Value<T[K1][K2][K3][K4]>) => Value<T[K1][K2][K3][K4]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(keyPath: [K1, K2, K3, K4], notSetValue: Value<T[K1][K2][K3][K4]>, updater: (value?: Value<T[K1][K2][K3][K4]>) => Value<T[K1][K2][K3][K4]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(keyPath: [K1, K2, K3, K4, K5], updater: (value?: Value<T[K1][K2][K3][K4][K5]>) => Value<T[K1][K2][K3][K4][K5]>): this;
  updateIn<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(keyPath: [K1, K2, K3, K4, K5], notSetValue: Value<T[K1][K2][K3][K4][K5]>, updater: (value?: Value<T[K1][K2][K3][K4][K5]>) => Value<T[K1][K2][K3][K4][K5]>): this;
  updateIn(keyPath: Iterable<any, any>, updater: (value?: any) => any): this;
  updateIn(keyPath: Iterable<any, any>, notSetValue: any, updater: (value?: any) => any): this;
  hasIn(searchKeyPath: any[] | Iterable<any, any>): boolean;
  toArray(): Array<Value<T[keyof T]>>;
  toObject(): {
    [K in keyof T]: Value<T[K]>;
  };
  toMap<K extends keyof T, V = Value<T[K]>>(): Map<K, V>;
  toOrderedMap<K extends keyof T, V = Value<T[K]>>(): OrderedMap<K, V>;
  toSet(): Set<Value<T[keyof T]>>;
  toSeq<K extends keyof T, V = Value<T[K]>>(): Seq<K, V>;
  toOrderedSet(): OrderedSet<Value<T[keyof T]>>;
  toList(): List<Value<T[keyof T]>>;
  keys(): keyof T;
  map<M, K extends keyof T>(mapper: (value?: Value<T[K]>, key?: K, iter?: this) => M, context?: any): this;
  values(): Iterator<Value<T[keyof T]>>;
  entries<K extends keyof T, V = Value<T[K]>>(): Iterator<[K, V]>;
  isEmpty(): boolean;
  count(): number;
}
interface IFromJS {
  <T extends object>(obj: T): IRecord<T>;
  <T extends object>(array: T[]): List<IRecord<T>>;
}
export declare const fromJS: IFromJS;
export { };
